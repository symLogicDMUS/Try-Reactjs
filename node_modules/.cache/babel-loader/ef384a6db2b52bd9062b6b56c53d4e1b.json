{"ast":null,"code":"import { getPieceType } from \"../../pieceType/getPieceType\";\nimport { pawn } from \"../../ranges/pawn/top/pawn\";\nimport { king } from \"../../ranges/king/top/king\";\nimport { getRange } from \"../../ranges/getRange\";\nimport { getColor } from \"../../color/getColor\";\nimport { getPieceLoc } from \"../../helpers/getPieceLoc\";\nimport { mapListXyToRf } from \"../../coordType/mapListXyToRf\";\nimport { rfToXy } from \"../../coordType/crdCnvrt\";\nimport { SpecialMoves } from \"../../ranges/specialMoves/SpecialMoves\";\nexport function getRanges(board, color, ranges, jsonRecords, pieceDefs, idDict) {\n  /**get the range of every piece on board of specific color, including special moves\n  these ranges are initial ranges. They don't take into consideration if the move endangers the king || not. This is\n  resolved the.includes(later) program &&  the initial ranges are then filtered\n  the ranges of special pieces Rook &&  Pawn (who's ranges cannot be fully defined by the defs format)\n  are resolved first, then for the Knight, Queen, Bishop, Rook, &&  any assignIds defined pieces.\n  defs[idDict] dict is a dict withs keys the non-special assigned ids, &&  values the names they're representing\n  defs_[pieceDefs] is a subset of defs.json\n  */\n  var pieceType, pieceRange;\n  var specialMoves = new SpecialMoves(null);\n\n  for (var [rf, id] of Object.entries(board)) {\n    if (id === '#') {\n      continue;\n    }\n\n    if (getColor(id) !== color) {\n      continue;\n    }\n\n    pieceType = getPieceType(id);\n\n    if (pieceType === 'P') {\n      [pieceRange, specialMoves] = pawn(board, rfToXy(rf), color, jsonRecords, specialMoves);\n      ranges[id].push(...pieceRange);\n    } else if (pieceType === 'K') {\n      [pieceRange, specialMoves] = king(board, rfToXy(rf), color, jsonRecords, specialMoves, pieceDefs, idDict);\n      ranges[id].push(...pieceRange);\n    } else {\n      pieceRange = getRange(board, rfToXy(rf), color, pieceDefs, idDict);\n      ranges[id].push(...pieceRange);\n    }\n  }\n\n  return [ranges, specialMoves];\n} // module.exports = getRanges;\n\n/** for node.js\nif (require.main === module) {\n    \n    import {JsonRecords} from \"../../JsonRecords/JsonRecords\";\n    import {initPawnIds} from \"../../JsonRecords/initPawnIds\"\n    import {sampleBoardDicts} from \"../../testObjects/sampleBoardDicts\";\n    import {getResetPieceDicts} from \"../../getters/getResetPieceDicts\";\n    import {getStandardPieceDefs} from \"../../testObjects/getStandardPieceDefs\";\n    import {getStandardIdDict} from \"../../testObjects/getStandardIdDict\";\n    import {initEmptyRanges} from \"../../apiHelpers/initEmptyRanges\";\n    import {initDDEmptyLists} from \"../../apiHelpers/initDDEmptyLists\"\n    import {dataDict} from \"../../testObjects/dataDicts/dd1\";\n    import {printBoard} from \"../../printers/printBoard\";\n\n    var board, jsonRecords, initRanges;\n    var idDict = getStandardIdDict()\n    var pieceDefs = initEmptyRanges(getStandardPieceDefs());\n    dataDict = initDDEmptyLists(dataDict);\n    \n    var game_names = [\n        'castle_test2',\n        'enpassant_test1',\n        'fundemental_defense',\n        'king_range_test',\n        'pawn_promo',\n        'ranges_test',\n        'stalemate_exp1',\n        'super_checkmate_impossible_example']\n\n    for (var game_name of game_names) {\n\n        board = sampleBoardDicts[game_name]\n        records = dataDict[game_name][\"json\"]\n        jsonRecords = new JsonRecords(initPawnIds(records, board))\n\n        var [initRanges, pins, mtRestricts, finalRanges] = getResetPieceDicts(board, 'W')\n        var [initRanges, specialMoves] = getRanges(board, 'W', initRanges, jsonRecords, pieceDefs, idDict);\n        for (var id of Object.keys(initRanges)) {\n            printBoard(board, `\\n${game_name}, ${id}`, mapListXyToRf(initRanges[id]), null, [getPieceLoc(board, id)])\n        }\n    }\n\n}\n*/","map":{"version":3,"sources":["/home/brian/ChessKingsCouncil/app/src/game_logic/ranges/top/getRanges.js"],"names":["getPieceType","pawn","king","getRange","getColor","getPieceLoc","mapListXyToRf","rfToXy","SpecialMoves","getRanges","board","color","ranges","jsonRecords","pieceDefs","idDict","pieceType","pieceRange","specialMoves","rf","id","Object","entries","push"],"mappings":"AAAA,SAAQA,YAAR,QAA2B,8BAA3B;AACA,SAAQC,IAAR,QAAmB,4BAAnB;AACA,SAAQC,IAAR,QAAmB,4BAAnB;AACA,SAAQC,QAAR,QAAuB,uBAAvB;AACA,SAAQC,QAAR,QAAuB,sBAAvB;AACA,SAAQC,WAAR,QAA0B,2BAA1B;AACA,SAAQC,aAAR,QAA4B,+BAA5B;AACA,SAAQC,MAAR,QAAqB,0BAArB;AACA,SAAQC,YAAR,QAA2B,wCAA3B;AAGA,OAAO,SAASC,SAAT,CAAmBC,KAAnB,EAA0BC,KAA1B,EAAiCC,MAAjC,EAAyCC,WAAzC,EAAsDC,SAAtD,EAAiEC,MAAjE,EAAyE;AAC5E;;;;;;;;AASA,MAAIC,SAAJ,EAAeC,UAAf;AACA,MAAIC,YAAY,GAAG,IAAIV,YAAJ,CAAiB,IAAjB,CAAnB;;AAEA,OAAK,IAAI,CAACW,EAAD,EAAKC,EAAL,CAAT,IAAqBC,MAAM,CAACC,OAAP,CAAeZ,KAAf,CAArB,EAA4C;AAExC,QAAIU,EAAE,KAAK,GAAX,EAAgB;AACZ;AACH;;AAED,QAAIhB,QAAQ,CAACgB,EAAD,CAAR,KAAiBT,KAArB,EAA4B;AACxB;AACH;;AAEDK,IAAAA,SAAS,GAAGhB,YAAY,CAACoB,EAAD,CAAxB;;AAEA,QAAIJ,SAAS,KAAK,GAAlB,EAAuB;AACnB,OAACC,UAAD,EAAaC,YAAb,IAA6BjB,IAAI,CAACS,KAAD,EAAQH,MAAM,CAACY,EAAD,CAAd,EAAoBR,KAApB,EAA2BE,WAA3B,EAAwCK,YAAxC,CAAjC;AACAN,MAAAA,MAAM,CAACQ,EAAD,CAAN,CAAWG,IAAX,CAAgB,GAAGN,UAAnB;AACH,KAHD,MAKK,IAAID,SAAS,KAAK,GAAlB,EAAuB;AACxB,OAACC,UAAD,EAAaC,YAAb,IAA6BhB,IAAI,CAACQ,KAAD,EAAQH,MAAM,CAACY,EAAD,CAAd,EAAoBR,KAApB,EAA2BE,WAA3B,EAAwCK,YAAxC,EAAsDJ,SAAtD,EAAiEC,MAAjE,CAAjC;AACAH,MAAAA,MAAM,CAACQ,EAAD,CAAN,CAAWG,IAAX,CAAgB,GAAGN,UAAnB;AACH,KAHI,MAKA;AACDA,MAAAA,UAAU,GAAGd,QAAQ,CAACO,KAAD,EAAQH,MAAM,CAACY,EAAD,CAAd,EAAoBR,KAApB,EAA2BG,SAA3B,EAAsCC,MAAtC,CAArB;AACAH,MAAAA,MAAM,CAACQ,EAAD,CAAN,CAAWG,IAAX,CAAgB,GAAGN,UAAnB;AACH;AACJ;;AAED,SAAO,CAACL,MAAD,EAASM,YAAT,CAAP;AACH,C,CAED;;AAEA","sourcesContent":["import {getPieceType} from \"../../pieceType/getPieceType\";\nimport {pawn} from \"../../ranges/pawn/top/pawn\";\nimport {king} from \"../../ranges/king/top/king\";\nimport {getRange} from \"../../ranges/getRange\";\nimport {getColor} from \"../../color/getColor\";\nimport {getPieceLoc} from \"../../helpers/getPieceLoc\";\nimport {mapListXyToRf} from \"../../coordType/mapListXyToRf\";\nimport {rfToXy} from \"../../coordType/crdCnvrt\"\nimport {SpecialMoves} from \"../../ranges/specialMoves/SpecialMoves\";\n\n\nexport function getRanges(board, color, ranges, jsonRecords, pieceDefs, idDict) {\n    /**get the range of every piece on board of specific color, including special moves\n    these ranges are initial ranges. They don't take into consideration if the move endangers the king || not. This is\n    resolved the.includes(later) program &&  the initial ranges are then filtered\n    the ranges of special pieces Rook &&  Pawn (who's ranges cannot be fully defined by the defs format)\n    are resolved first, then for the Knight, Queen, Bishop, Rook, &&  any assignIds defined pieces.\n    defs[idDict] dict is a dict withs keys the non-special assigned ids, &&  values the names they're representing\n    defs_[pieceDefs] is a subset of defs.json\n    */\n\n    var pieceType, pieceRange;\n    var specialMoves = new SpecialMoves(null);\n\n    for (var [rf, id] of Object.entries(board)) {\n\n        if (id === '#') {\n            continue\n        }\n\n        if (getColor(id) !== color) {\n            continue\n        }\n\n        pieceType = getPieceType(id)\n\n        if (pieceType === 'P') {\n            [pieceRange, specialMoves] = pawn(board, rfToXy(rf), color, jsonRecords, specialMoves)\n            ranges[id].push(...pieceRange)\n        }\n\n        else if (pieceType === 'K') {\n            [pieceRange, specialMoves] = king(board, rfToXy(rf), color, jsonRecords, specialMoves, pieceDefs, idDict)\n            ranges[id].push(...pieceRange)\n        }\n\n        else {\n            pieceRange = getRange(board, rfToXy(rf), color, pieceDefs, idDict)\n            ranges[id].push(...pieceRange)\n        }\n    }\n\n    return [ranges, specialMoves]\n}\n\n// module.exports = getRanges;\n\n/** for node.js\nif (require.main === module) {\n    \n    import {JsonRecords} from \"../../JsonRecords/JsonRecords\";\n    import {initPawnIds} from \"../../JsonRecords/initPawnIds\"\n    import {sampleBoardDicts} from \"../../testObjects/sampleBoardDicts\";\n    import {getResetPieceDicts} from \"../../getters/getResetPieceDicts\";\n    import {getStandardPieceDefs} from \"../../testObjects/getStandardPieceDefs\";\n    import {getStandardIdDict} from \"../../testObjects/getStandardIdDict\";\n    import {initEmptyRanges} from \"../../apiHelpers/initEmptyRanges\";\n    import {initDDEmptyLists} from \"../../apiHelpers/initDDEmptyLists\"\n    import {dataDict} from \"../../testObjects/dataDicts/dd1\";\n    import {printBoard} from \"../../printers/printBoard\";\n\n    var board, jsonRecords, initRanges;\n    var idDict = getStandardIdDict()\n    var pieceDefs = initEmptyRanges(getStandardPieceDefs());\n    dataDict = initDDEmptyLists(dataDict);\n    \n    var game_names = [\n        'castle_test2',\n        'enpassant_test1',\n        'fundemental_defense',\n        'king_range_test',\n        'pawn_promo',\n        'ranges_test',\n        'stalemate_exp1',\n        'super_checkmate_impossible_example']\n\n    for (var game_name of game_names) {\n\n        board = sampleBoardDicts[game_name]\n        records = dataDict[game_name][\"json\"]\n        jsonRecords = new JsonRecords(initPawnIds(records, board))\n\n        var [initRanges, pins, mtRestricts, finalRanges] = getResetPieceDicts(board, 'W')\n        var [initRanges, specialMoves] = getRanges(board, 'W', initRanges, jsonRecords, pieceDefs, idDict);\n        for (var id of Object.keys(initRanges)) {\n            printBoard(board, `\\n${game_name}, ${id}`, mapListXyToRf(initRanges[id]), null, [getPieceLoc(board, id)])\n        }\n    }\n\n}\n*/"]},"metadata":{},"sourceType":"module"}