{"ast":null,"code":"import { getRanges } from \"../game_logic/ranges/top/getRanges\";\nimport { getPathdataDict } from \"../game_logic/pathsInfo/top/getpathDataDict\";\nimport { getResetPieceDicts } from \"../game_logic/getters/getResetPieceDicts\";\nimport { getKingLocs } from \"../game_logic/threatArea/getKingLocs\";\nimport { getThreatArea } from \"../game_logic/threatArea/top/getThreatArea\";\nimport { getNumPiecesCheckingKing } from \"../game_logic/restriction/getNumPiecesCheckingKing\";\nimport { getMultithreatRestriction } from \"../game_logic/restriction/getMultithreatRestriction\";\nimport { getFinalRanges } from \"../game_logic/ranges/top/getFinalRanges\";\nimport { getPins } from \"../game_logic/pins/top/getPins\";\nimport { convertToRf } from \"../game_logic/coordType/convertToRf\";\nimport { isEmptyRanges } from \"../game_logic/helpers/isEmptyRanges\";\nimport { noRanges } from \"../game_logic/fenParser/GameStatus/noRanges\";\nimport { aiMove } from \"./aiMove\";\nexport function getTurnData(board, color, aiColor, jsonRecords, pieceDefs, idDict) {\n  /**data for player who's turn it is now, at current the.includes(point) game\n  calculations:\n  ............\n  final ranges: where every piece of player's pieces can move to.\n  status: is it check, checkmate, stalemate or none of these? is the game over?\n  aiStart: the starting square of a move if it is the computer's turn\n  aiDest: the ending square of a move if it is the computer's turn\n  ............\n  */\n  var [initRanges, pins, mtRestricts, finalRanges] = getResetPieceDicts(board, color);\n  var [initRanges, specialMoves] = getRanges(board, color, initRanges, jsonRecords, pieceDefs, idDict);\n  var kLoc = getKingLocs(board, color);\n  var threatArea = getThreatArea(board, kLoc, color, pieceDefs, idDict);\n  var pdDict = getPathdataDict(board, kLoc, color, pieceDefs, idDict);\n  var pins = getPins(pdDict, pins);\n  var npck = getNumPiecesCheckingKing(board, kLoc, color, pdDict, pieceDefs, idDict);\n  var mtRestricts = getMultithreatRestriction(board, npck, color);\n  [initRanges, pins, threatArea, mtRestricts] = convertToRf(initRanges, pins, threatArea, mtRestricts);\n  finalRanges = getFinalRanges(initRanges, pins, threatArea, finalRanges, mtRestricts); // finalRanges in rf format\n  // specialMoves.setPromos(board, finalRanges, color);\n\n  var aiCapture, aiStart, aiDest;\n\n  if (color === aiColor && !noRanges(finalRanges)) {\n    [aiCapture, aiStart, aiDest] = aiMove(board, finalRanges, aiColor, specialMoves);\n  } else {\n    [aiCapture, aiStart, aiDest] = [false, false, false];\n  }\n\n  specialMoves.convertToRf();\n  return {\n    ranges: finalRanges,\n    special_moves: specialMoves.getMoves(),\n    ai_start: aiStart,\n    ai_dest: aiDest,\n    ai_capture: aiCapture,\n    npck: npck\n  };\n} // module.exports = getTurnData;\n\n/** for node.js\nif (require.main === module) {\n\n    import {getStandardPieceDefs} from \"../testObjects/getStandardPieceDefs\"\n    import {getStandardIdDict} from \"../testObjects/getStandardIdDict\";\n    import {initEmptyRanges} from \"./initEmptyRanges\"\n    import {initDDEmptyLists} from \"./initDDEmptyLists\";\n    import {initPawnIds} from \"../JsonRecords/initPawnIds\";\n    import {sampleBoardDicts} from \"../testObjects/sampleBoardDicts\";\n    import {JsonRecords} from \"../JsonRecords/JsonRecords\";\n    import {getPieceLoc} from \"../helpers/getPieceLoc\"\n    import {dataDict} from \"../testObjects/dataDicts/dd1\";\n    import {pieceDefs} from \"../game_logic/testObjects/standardPieceDefs\";\n    import {printBoard} from \"../game_logic/printers/printBoard\";\n    \n    dataDict = initDDEmptyLists(dataDict)\n    const pieceDefs = initEmptyRanges(getStandardPieceDefs())\n    const idDict = getStandardIdDict()\n\n    var board, jsonRecords;\n\n    var game_names = [\n      'castle_test1',\n      'castle_test2',\n      'castle_test3',\n      'castle_test4',\n      'check_example1',\n      'check_example2',\n      'check_example3',\n      'check_example4',\n      'check_example6',\n      'dummy_game',\n      'king_range_test',\n      'knight_threat1',\n      'knight_threat2',\n      'pawn_promo',\n      'pawn_range',\n      'pawn_threat1',\n      'ranges_test',\n      'pinned_ex1',\n      'pinned_ex2',\n      'stalemate_exp1',\n      'enpassant_test1',\n      'fundemental_defense',\n      'super_checkmate_impossible_example'\n    ]\n\n    for (var game_name of game_names) {\n        console.log(`------------------------ ${game_name} ------------------------`.green)\n        board = sampleBoardDicts[game_name]\n        records = dataDict[game_name][\"json\"]\n        jsonRecords = new JsonRecords(initPawnIds(records, board))\n        var [finalRanges, specialMoves] = getTurnData(board, 'W', 'B', jsonRecords, pieceDefs, idDict)\n        for (var id of Object.keys(finalRanges)) {\n            printBoard(board, `\\n${id}`, finalRanges[id], null, [getPieceLoc(board, id)])\n        }\n    }\n\n}\n*/","map":{"version":3,"sources":["/home/brian/ChessKingsCouncil/app/src/apiHelpers/getTurnData.js"],"names":["getRanges","getPathdataDict","getResetPieceDicts","getKingLocs","getThreatArea","getNumPiecesCheckingKing","getMultithreatRestriction","getFinalRanges","getPins","convertToRf","isEmptyRanges","noRanges","aiMove","getTurnData","board","color","aiColor","jsonRecords","pieceDefs","idDict","initRanges","pins","mtRestricts","finalRanges","specialMoves","kLoc","threatArea","pdDict","npck","aiCapture","aiStart","aiDest","ranges","special_moves","getMoves","ai_start","ai_dest","ai_capture"],"mappings":"AAAA,SAAQA,SAAR,QAAwB,oCAAxB;AACA,SAAQC,eAAR,QAA8B,6CAA9B;AACA,SAAQC,kBAAR,QAAiC,0CAAjC;AACA,SAAQC,WAAR,QAA0B,sCAA1B;AACA,SAAQC,aAAR,QAA4B,4CAA5B;AACA,SAAQC,wBAAR,QAAuC,oDAAvC;AACA,SAAQC,yBAAR,QAAwC,qDAAxC;AACA,SAAQC,cAAR,QAA6B,yCAA7B;AACA,SAAQC,OAAR,QAAsB,gCAAtB;AACA,SAAQC,WAAR,QAA0B,qCAA1B;AACA,SAASC,aAAT,QAA8B,qCAA9B;AACA,SAASC,QAAT,QAAyB,6CAAzB;AACA,SAAQC,MAAR,QAAqB,UAArB;AAGA,OAAO,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,KAA5B,EAAmCC,OAAnC,EAA4CC,WAA5C,EAAyDC,SAAzD,EAAoEC,MAApE,EAA4E;AAC/E;;;;;;;;;AASA,MAAI,CAACC,UAAD,EAAaC,IAAb,EAAmBC,WAAnB,EAAgCC,WAAhC,IAA+CrB,kBAAkB,CAACY,KAAD,EAAQC,KAAR,CAArE;AACA,MAAI,CAACK,UAAD,EAAaI,YAAb,IAA6BxB,SAAS,CAACc,KAAD,EAAQC,KAAR,EAAeK,UAAf,EAA2BH,WAA3B,EAAwCC,SAAxC,EAAmDC,MAAnD,CAA1C;AACA,MAAIM,IAAI,GAAGtB,WAAW,CAACW,KAAD,EAAQC,KAAR,CAAtB;AACA,MAAIW,UAAU,GAAGtB,aAAa,CAACU,KAAD,EAAQW,IAAR,EAAcV,KAAd,EAAqBG,SAArB,EAAgCC,MAAhC,CAA9B;AACA,MAAIQ,MAAM,GAAG1B,eAAe,CAACa,KAAD,EAAQW,IAAR,EAAcV,KAAd,EAAqBG,SAArB,EAAgCC,MAAhC,CAA5B;AACA,MAAIE,IAAI,GAAGb,OAAO,CAACmB,MAAD,EAASN,IAAT,CAAlB;AACA,MAAIO,IAAI,GAAGvB,wBAAwB,CAACS,KAAD,EAAQW,IAAR,EAAcV,KAAd,EAAqBY,MAArB,EAA6BT,SAA7B,EAAwCC,MAAxC,CAAnC;AACA,MAAIG,WAAW,GAAGhB,yBAAyB,CAACQ,KAAD,EAAQc,IAAR,EAAcb,KAAd,CAA3C;AACA,GAACK,UAAD,EAAaC,IAAb,EAAmBK,UAAnB,EAA+BJ,WAA/B,IAA8Cb,WAAW,CAACW,UAAD,EAAaC,IAAb,EAAmBK,UAAnB,EAA+BJ,WAA/B,CAAzD;AACAC,EAAAA,WAAW,GAAGhB,cAAc,CAACa,UAAD,EAAaC,IAAb,EAAmBK,UAAnB,EAA+BH,WAA/B,EAA4CD,WAA5C,CAA5B,CAnB+E,CAmBO;AACtF;;AAEA,MAAIO,SAAJ,EAAeC,OAAf,EAAwBC,MAAxB;;AACA,MAAIhB,KAAK,KAAKC,OAAV,IAAqB,CAAEL,QAAQ,CAACY,WAAD,CAAnC,EAAkD;AAC9C,KAACM,SAAD,EAAYC,OAAZ,EAAqBC,MAArB,IAA+BnB,MAAM,CAACE,KAAD,EAAQS,WAAR,EAAqBP,OAArB,EAA8BQ,YAA9B,CAArC;AACH,GAFD,MAGK;AACD,KAACK,SAAD,EAAYC,OAAZ,EAAqBC,MAArB,IAA+B,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,CAA/B;AACH;;AAEDP,EAAAA,YAAY,CAACf,WAAb;AAEA,SAAO;AACHuB,IAAAA,MAAM,EAAET,WADL;AAEHU,IAAAA,aAAa,EAAET,YAAY,CAACU,QAAb,EAFZ;AAGHC,IAAAA,QAAQ,EAAEL,OAHP;AAIHM,IAAAA,OAAO,EAAEL,MAJN;AAKHM,IAAAA,UAAU,EAAER,SALT;AAMHD,IAAAA,IAAI,EAAEA;AANH,GAAP;AASH,C,CAED;;AAEA","sourcesContent":["import {getRanges} from \"../game_logic/ranges/top/getRanges\";\nimport {getPathdataDict} from \"../game_logic/pathsInfo/top/getpathDataDict\";\nimport {getResetPieceDicts} from \"../game_logic/getters/getResetPieceDicts\";\nimport {getKingLocs} from \"../game_logic/threatArea/getKingLocs\";\nimport {getThreatArea} from \"../game_logic/threatArea/top/getThreatArea\";\nimport {getNumPiecesCheckingKing} from \"../game_logic/restriction/getNumPiecesCheckingKing\";\nimport {getMultithreatRestriction} from \"../game_logic/restriction/getMultithreatRestriction\";\nimport {getFinalRanges} from \"../game_logic/ranges/top/getFinalRanges\";\nimport {getPins} from \"../game_logic/pins/top/getPins\";\nimport {convertToRf} from \"../game_logic/coordType/convertToRf\"\nimport { isEmptyRanges } from \"../game_logic/helpers/isEmptyRanges\";\nimport { noRanges } from \"../game_logic/fenParser/GameStatus/noRanges\";\nimport {aiMove} from \"./aiMove\";\n\n\nexport function getTurnData(board, color, aiColor, jsonRecords, pieceDefs, idDict) {\n    /**data for player who's turn it is now, at current the.includes(point) game\n    calculations:\n    ............\n    final ranges: where every piece of player's pieces can move to.\n    status: is it check, checkmate, stalemate or none of these? is the game over?\n    aiStart: the starting square of a move if it is the computer's turn\n    aiDest: the ending square of a move if it is the computer's turn\n    ............\n    */\n    var [initRanges, pins, mtRestricts, finalRanges] = getResetPieceDicts(board, color);\n    var [initRanges, specialMoves] = getRanges(board, color, initRanges, jsonRecords, pieceDefs, idDict);\n    var kLoc = getKingLocs(board, color);\n    var threatArea = getThreatArea(board, kLoc, color, pieceDefs, idDict);\n    var pdDict = getPathdataDict(board, kLoc, color, pieceDefs, idDict);\n    var pins = getPins(pdDict, pins);\n    var npck = getNumPiecesCheckingKing(board, kLoc, color, pdDict, pieceDefs, idDict);\n    var mtRestricts = getMultithreatRestriction(board, npck, color);\n    [initRanges, pins, threatArea, mtRestricts] = convertToRf(initRanges, pins, threatArea, mtRestricts)\n    finalRanges = getFinalRanges(initRanges, pins, threatArea, finalRanges, mtRestricts); // finalRanges in rf format\n    // specialMoves.setPromos(board, finalRanges, color);\n\n    var aiCapture, aiStart, aiDest;\n    if (color === aiColor && ! noRanges(finalRanges)) {\n        [aiCapture, aiStart, aiDest] = aiMove(board, finalRanges, aiColor, specialMoves);\n    }\n    else {\n        [aiCapture, aiStart, aiDest] = [false, false, false]\n    }\n\n    specialMoves.convertToRf()\n\n    return {\n        ranges: finalRanges,\n        special_moves: specialMoves.getMoves(),\n        ai_start: aiStart,\n        ai_dest: aiDest,\n        ai_capture: aiCapture,\n        npck: npck,\n    };\n\n}\n\n// module.exports = getTurnData;\n\n/** for node.js\nif (require.main === module) {\n\n    import {getStandardPieceDefs} from \"../testObjects/getStandardPieceDefs\"\n    import {getStandardIdDict} from \"../testObjects/getStandardIdDict\";\n    import {initEmptyRanges} from \"./initEmptyRanges\"\n    import {initDDEmptyLists} from \"./initDDEmptyLists\";\n    import {initPawnIds} from \"../JsonRecords/initPawnIds\";\n    import {sampleBoardDicts} from \"../testObjects/sampleBoardDicts\";\n    import {JsonRecords} from \"../JsonRecords/JsonRecords\";\n    import {getPieceLoc} from \"../helpers/getPieceLoc\"\n    import {dataDict} from \"../testObjects/dataDicts/dd1\";\n    import {pieceDefs} from \"../game_logic/testObjects/standardPieceDefs\";\n    import {printBoard} from \"../game_logic/printers/printBoard\";\n    \n    dataDict = initDDEmptyLists(dataDict)\n    const pieceDefs = initEmptyRanges(getStandardPieceDefs())\n    const idDict = getStandardIdDict()\n\n    var board, jsonRecords;\n\n    var game_names = [\n      'castle_test1',\n      'castle_test2',\n      'castle_test3',\n      'castle_test4',\n      'check_example1',\n      'check_example2',\n      'check_example3',\n      'check_example4',\n      'check_example6',\n      'dummy_game',\n      'king_range_test',\n      'knight_threat1',\n      'knight_threat2',\n      'pawn_promo',\n      'pawn_range',\n      'pawn_threat1',\n      'ranges_test',\n      'pinned_ex1',\n      'pinned_ex2',\n      'stalemate_exp1',\n      'enpassant_test1',\n      'fundemental_defense',\n      'super_checkmate_impossible_example'\n    ]\n\n    for (var game_name of game_names) {\n        console.log(`------------------------ ${game_name} ------------------------`.green)\n        board = sampleBoardDicts[game_name]\n        records = dataDict[game_name][\"json\"]\n        jsonRecords = new JsonRecords(initPawnIds(records, board))\n        var [finalRanges, specialMoves] = getTurnData(board, 'W', 'B', jsonRecords, pieceDefs, idDict)\n        for (var id of Object.keys(finalRanges)) {\n            printBoard(board, `\\n${id}`, finalRanges[id], null, [getPieceLoc(board, id)])\n        }\n    }\n\n}\n*/"]},"metadata":{},"sourceType":"module"}