{"ast":null,"code":"import { getEnPassantAlignmentKey } from \"../../../ranges/specialMoves/enPassant/getEnPassantAlignmentKey\";\nimport { getPotential1SqrJump } from \"../getPotential1SqrJump\";\nimport { canEnpassant } from \"../../specialMoves/enPassant/canEnPassant\";\nimport { getPotentialCaptures } from \"../getPotentialCaptures\";\nimport { isActual1SqrJump } from \"../isActual1SqrJump\";\nimport { getActualCaptures } from \"../getActualCaptures\";\nimport { valid2SqrJump } from \"../valid2SqrJump\";\nimport { get2SqrJump } from \"../get2SqrJump\";\nimport { getTSqr } from \"../../specialMoves/enPassant/getTSqr\";\nimport { step_1sqr0d, step_1sqr180d } from \"../../../helpers/stepFuncs\";\nexport function pawn(board, sqr, color, jsonRecords, specialMoves) {\n  /*get the range of pawn at location sqr and of the given color**/\n  var range = [];\n  var twoSqrJump, alignKey, tSqr, twoSqrJump, potentialCaptures;\n  let potential1Sqr = getPotential1SqrJump(sqr, color);\n\n  if (isActual1SqrJump(board, potential1Sqr, color)) {\n    range.push(potential1Sqr);\n  }\n\n  if (valid2SqrJump(board, sqr, color, jsonRecords.pawnHistories)) {\n    twoSqrJump = get2SqrJump(sqr, color);\n    range.push(twoSqrJump);\n  }\n\n  if (canEnpassant(sqr, step_1sqr180d(...sqr), board, color, jsonRecords.pawnHistories, jsonRecords.numConsecutiveNonPawnMoves, jsonRecords.lastPawnMove)) {\n    alignKey = getEnPassantAlignmentKey(sqr, step_1sqr180d(...sqr));\n    tSqr = getTSqr(color, alignKey);\n    range.push(tSqr);\n    specialMoves.addEnPassant([sqr, tSqr]);\n  } else if (canEnpassant(sqr, step_1sqr0d(...sqr), board, color, jsonRecords.pawnHistories, jsonRecords.numConsecutiveNonPawnMoves, jsonRecords.lastPawnMove)) {\n    alignKey = getEnPassantAlignmentKey(sqr, step_1sqr0d(...sqr));\n    tSqr = getTSqr(color, alignKey);\n    range.push(tSqr);\n    specialMoves.addEnPassant([sqr, tSqr]);\n  }\n\n  potentialCaptures = getPotentialCaptures(sqr, color);\n  range.push(...getActualCaptures(board, potentialCaptures, color));\n  specialMoves.setPromos(board, sqr, range);\n  return [range, specialMoves];\n} // module.exports = pawn;\n\n/** for node.js\nif (require.main === module) {\n    \n    import {dataDict} from \"../../../testObjects/dataDicts/dd1\";\n\n    var board, range, specialMoves, whiteLocs, blackLocs, jsonRecords;\n\n    \n    board = sampleBoardDicts[\"pawn_range\"]\n    jsonRecords = new JsonRecords(initPawnIds(dataDict[\"pawn_range\"][\"json\"], board))\n    specialMoves = new SpecialMoves()\n    blackLocs = [[1, 7], [2, 6], [3, 7], [6, 7], [7, 7], [4, 5], [5, 5], [8, 5]]\n    whiteLocs = [[1, 2], [4, 2], [6, 2], [8, 2], [2, 4], [3, 4], [5, 4], [7, 5]]\n    for (var sqr of whiteLocs) {\n        [range, specialMoves] = pawn(board, sqr, 'W', jsonRecords, specialMoves)\n        printBoard(board, '\\nwhite', mapListXyToRf(range), null, [xyToRf(...sqr)])\n    }\n    for (var sqr of blackLocs) {\n        [range, specialMoves] = pawn(board, sqr, 'B', jsonRecords, specialMoves)\n        printBoard(board, '\\nblack', mapListXyToRf(range), null, [xyToRf(...sqr)])\n    }\n\n\n    board = sampleBoardDicts[\"enpassant_test1\"]\n    jsonRecords = new JsonRecords(initPawnIds(dataDict[\"enpassant_test1\"][\"json\"], board))\n    specialMoves = new SpecialMoves()\n    blackLocs = [[1, 7], [2, 5], [3, 7], [4, 7], [5, 7], [6, 7], [7, 7], [8, 7]]\n    whiteLocs = [[1, 2], [2, 2], [3, 5], [4, 2], [5, 2], [6, 2], [7, 2], [8, 2]]\n    for (var sqr of whiteLocs) {\n        [range, specialMoves] = pawn(board, sqr, 'W', jsonRecords, specialMoves)\n        printBoard(board, '\\nwhite', mapListXyToRf(range), null, [xyToRf(...sqr)])\n    }\n    for (var sqr of blackLocs) {\n        [range, specialMoves] = pawn(board, sqr, 'B', jsonRecords, specialMoves)\n        printBoard(board, '\\nblack', mapListXyToRf(range), null, [xyToRf(...sqr)])\n    }\n\n}\n*/","map":{"version":3,"sources":["/home/brian/ChessKingsCouncil/app/src/game_logic/ranges/pawn/top/pawn.js"],"names":["getEnPassantAlignmentKey","getPotential1SqrJump","canEnpassant","getPotentialCaptures","isActual1SqrJump","getActualCaptures","valid2SqrJump","get2SqrJump","getTSqr","step_1sqr0d","step_1sqr180d","pawn","board","sqr","color","jsonRecords","specialMoves","range","twoSqrJump","alignKey","tSqr","potentialCaptures","potential1Sqr","push","pawnHistories","numConsecutiveNonPawnMoves","lastPawnMove","addEnPassant","setPromos"],"mappings":"AAAA,SAAQA,wBAAR,QAAuC,iEAAvC;AACA,SAAQC,oBAAR,QAAmC,yBAAnC;AACA,SAAQC,YAAR,QAA2B,2CAA3B;AACA,SAAQC,oBAAR,QAAmC,yBAAnC;AACA,SAAQC,gBAAR,QAA+B,qBAA/B;AACA,SAAQC,iBAAR,QAAgC,sBAAhC;AACA,SAAQC,aAAR,QAA4B,kBAA5B;AACA,SAAQC,WAAR,QAA0B,gBAA1B;AACA,SAAQC,OAAR,QAAsB,sCAAtB;AACA,SAAQC,WAAR,EAAqBC,aAArB,QAAyC,4BAAzC;AAGA,OAAO,SAASC,IAAT,CAAcC,KAAd,EAAqBC,GAArB,EAA0BC,KAA1B,EAAiCC,WAAjC,EAA8CC,YAA9C,EAA4D;AAC/D;AAEA,MAAIC,KAAK,GAAG,EAAZ;AACA,MAAIC,UAAJ,EAAgBC,QAAhB,EAA0BC,IAA1B,EAAgCF,UAAhC,EAA4CG,iBAA5C;AACA,MAAIC,aAAa,GAAGrB,oBAAoB,CAACY,GAAD,EAAMC,KAAN,CAAxC;;AAEA,MAAIV,gBAAgB,CAACQ,KAAD,EAAQU,aAAR,EAAuBR,KAAvB,CAApB,EAAmD;AAC/CG,IAAAA,KAAK,CAACM,IAAN,CAAWD,aAAX;AACH;;AAED,MAAIhB,aAAa,CAACM,KAAD,EAAQC,GAAR,EAAaC,KAAb,EAAoBC,WAAW,CAACS,aAAhC,CAAjB,EAAiE;AAC7DN,IAAAA,UAAU,GAAGX,WAAW,CAACM,GAAD,EAAMC,KAAN,CAAxB;AACAG,IAAAA,KAAK,CAACM,IAAN,CAAWL,UAAX;AACH;;AAED,MACIhB,YAAY,CACRW,GADQ,EAERH,aAAa,CAAC,GAAGG,GAAJ,CAFL,EAGRD,KAHQ,EAIRE,KAJQ,EAKRC,WAAW,CAACS,aALJ,EAMRT,WAAW,CAACU,0BANJ,EAORV,WAAW,CAACW,YAPJ,CADhB,EAUE;AACEP,IAAAA,QAAQ,GAAGnB,wBAAwB,CAACa,GAAD,EAAMH,aAAa,CAAC,GAAGG,GAAJ,CAAnB,CAAnC;AACAO,IAAAA,IAAI,GAAGZ,OAAO,CAACM,KAAD,EAAQK,QAAR,CAAd;AACAF,IAAAA,KAAK,CAACM,IAAN,CAAWH,IAAX;AACAJ,IAAAA,YAAY,CAACW,YAAb,CAA0B,CAACd,GAAD,EAAMO,IAAN,CAA1B;AACH,GAfD,MAiBK,IACDlB,YAAY,CACRW,GADQ,EAERJ,WAAW,CAAC,GAAGI,GAAJ,CAFH,EAGRD,KAHQ,EAIRE,KAJQ,EAKRC,WAAW,CAACS,aALJ,EAMRT,WAAW,CAACU,0BANJ,EAORV,WAAW,CAACW,YAPJ,CADX,EAUH;AACEP,IAAAA,QAAQ,GAAGnB,wBAAwB,CAACa,GAAD,EAAMJ,WAAW,CAAC,GAAGI,GAAJ,CAAjB,CAAnC;AACAO,IAAAA,IAAI,GAAGZ,OAAO,CAACM,KAAD,EAAQK,QAAR,CAAd;AACAF,IAAAA,KAAK,CAACM,IAAN,CAAWH,IAAX;AACAJ,IAAAA,YAAY,CAACW,YAAb,CAA0B,CAACd,GAAD,EAAMO,IAAN,CAA1B;AACH;;AAEDC,EAAAA,iBAAiB,GAAGlB,oBAAoB,CAACU,GAAD,EAAMC,KAAN,CAAxC;AACAG,EAAAA,KAAK,CAACM,IAAN,CAAW,GAAGlB,iBAAiB,CAACO,KAAD,EAAOS,iBAAP,EAA0BP,KAA1B,CAA/B;AAEAE,EAAAA,YAAY,CAACY,SAAb,CAAuBhB,KAAvB,EAA8BC,GAA9B,EAAmCI,KAAnC;AAEA,SAAO,CAACA,KAAD,EAAQD,YAAR,CAAP;AACH,C,CAED;;AAEA","sourcesContent":["import {getEnPassantAlignmentKey} from \"../../../ranges/specialMoves/enPassant/getEnPassantAlignmentKey\";\nimport {getPotential1SqrJump} from \"../getPotential1SqrJump\"\nimport {canEnpassant} from \"../../specialMoves/enPassant/canEnPassant\";\nimport {getPotentialCaptures} from \"../getPotentialCaptures\";\nimport {isActual1SqrJump} from \"../isActual1SqrJump\";\nimport {getActualCaptures} from \"../getActualCaptures\";\nimport {valid2SqrJump} from \"../valid2SqrJump\";\nimport {get2SqrJump} from \"../get2SqrJump\";\nimport {getTSqr} from \"../../specialMoves/enPassant/getTSqr\";\nimport {step_1sqr0d, step_1sqr180d} from \"../../../helpers/stepFuncs\";\n\n\nexport function pawn(board, sqr, color, jsonRecords, specialMoves) {\n    /*get the range of pawn at location sqr and of the given color**/\n\n    var range = [];\n    var twoSqrJump, alignKey, tSqr, twoSqrJump, potentialCaptures;\n    let potential1Sqr = getPotential1SqrJump(sqr, color);\n\n    if (isActual1SqrJump(board, potential1Sqr, color)) {\n        range.push(potential1Sqr);\n    }\n\n    if (valid2SqrJump(board, sqr, color, jsonRecords.pawnHistories)) {\n        twoSqrJump = get2SqrJump(sqr, color);\n        range.push(twoSqrJump);\n    }\n\n    if (\n        canEnpassant(\n            sqr,\n            step_1sqr180d(...sqr),\n            board,\n            color,\n            jsonRecords.pawnHistories,\n            jsonRecords.numConsecutiveNonPawnMoves,\n            jsonRecords.lastPawnMove\n        )\n    ) {\n        alignKey = getEnPassantAlignmentKey(sqr, step_1sqr180d(...sqr));\n        tSqr = getTSqr(color, alignKey);\n        range.push(tSqr);\n        specialMoves.addEnPassant([sqr, tSqr]);\n    } \n    \n    else if (\n        canEnpassant(\n            sqr,\n            step_1sqr0d(...sqr),\n            board,\n            color,\n            jsonRecords.pawnHistories,\n            jsonRecords.numConsecutiveNonPawnMoves,\n            jsonRecords.lastPawnMove\n        )\n    ) {\n        alignKey = getEnPassantAlignmentKey(sqr, step_1sqr0d(...sqr));\n        tSqr = getTSqr(color, alignKey);\n        range.push(tSqr);\n        specialMoves.addEnPassant([sqr, tSqr]);\n    }\n\n    potentialCaptures = getPotentialCaptures(sqr, color);\n    range.push(...getActualCaptures(board,potentialCaptures, color));\n\n    specialMoves.setPromos(board, sqr, range)\n\n    return [range, specialMoves];\n}\n\n// module.exports = pawn;\n\n/** for node.js\nif (require.main === module) {\n    \n    import {dataDict} from \"../../../testObjects/dataDicts/dd1\";\n\n    var board, range, specialMoves, whiteLocs, blackLocs, jsonRecords;\n\n    \n    board = sampleBoardDicts[\"pawn_range\"]\n    jsonRecords = new JsonRecords(initPawnIds(dataDict[\"pawn_range\"][\"json\"], board))\n    specialMoves = new SpecialMoves()\n    blackLocs = [[1, 7], [2, 6], [3, 7], [6, 7], [7, 7], [4, 5], [5, 5], [8, 5]]\n    whiteLocs = [[1, 2], [4, 2], [6, 2], [8, 2], [2, 4], [3, 4], [5, 4], [7, 5]]\n    for (var sqr of whiteLocs) {\n        [range, specialMoves] = pawn(board, sqr, 'W', jsonRecords, specialMoves)\n        printBoard(board, '\\nwhite', mapListXyToRf(range), null, [xyToRf(...sqr)])\n    }\n    for (var sqr of blackLocs) {\n        [range, specialMoves] = pawn(board, sqr, 'B', jsonRecords, specialMoves)\n        printBoard(board, '\\nblack', mapListXyToRf(range), null, [xyToRf(...sqr)])\n    }\n\n\n    board = sampleBoardDicts[\"enpassant_test1\"]\n    jsonRecords = new JsonRecords(initPawnIds(dataDict[\"enpassant_test1\"][\"json\"], board))\n    specialMoves = new SpecialMoves()\n    blackLocs = [[1, 7], [2, 5], [3, 7], [4, 7], [5, 7], [6, 7], [7, 7], [8, 7]]\n    whiteLocs = [[1, 2], [2, 2], [3, 5], [4, 2], [5, 2], [6, 2], [7, 2], [8, 2]]\n    for (var sqr of whiteLocs) {\n        [range, specialMoves] = pawn(board, sqr, 'W', jsonRecords, specialMoves)\n        printBoard(board, '\\nwhite', mapListXyToRf(range), null, [xyToRf(...sqr)])\n    }\n    for (var sqr of blackLocs) {\n        [range, specialMoves] = pawn(board, sqr, 'B', jsonRecords, specialMoves)\n        printBoard(board, '\\nblack', mapListXyToRf(range), null, [xyToRf(...sqr)])\n    }\n\n}\n*/"]},"metadata":{},"sourceType":"module"}