{"ast":null,"code":"import { getPieceColor } from \"../color/getPieceColor\";\nimport { getNextColor as getEnemyColor } from \"../color/getNextColor\";\nimport { strfind } from \"../helpers/strfind\";\nimport { rfToXy } from \"../coordType/crdCnvrt\";\nimport { mapListRfToXy } from \"../coordType/mapListRfToXy\";\nexport function getOffsetThreats(board, kingLoc, color, pieceDefs, idDict) {\n  /* **/\n  var id, sqr, offset, pieceName, boardFilter1, boardFilter2, boardFilter3, boardFilter4; //filter out empty squares\n\n  boardFilter1 = {};\n\n  for (var rf of Object.keys(board)) {\n    if (board[rf] != '#') {\n      boardFilter1[rf] = board[rf];\n    }\n  } //only include piece if not the same color\n\n\n  boardFilter2 = {};\n\n  for (var rf of Object.keys(boardFilter1)) {\n    if (getPieceColor(boardFilter1[rf]) != color) {\n      boardFilter2[rf] = boardFilter1[rf];\n    }\n  } //filter out King and Pawn (special pieces)\n\n\n  boardFilter3 = {};\n\n  for (var rf of Object.keys(boardFilter2)) {\n    id = board[rf];\n    pieceName = idDict[id[1].toLowerCase()];\n\n    if (pieceName != \"King\" && pieceName != \"Pawn\") {\n      boardFilter3[rf] = boardFilter2[rf];\n    }\n  } //only include pieces that have offsets that hit the king, as part of their range\n\n\n  boardFilter4 = {};\n\n  for (var rf of Object.keys(boardFilter3)) {\n    id = board[rf];\n    sqr = rfToXy(rf);\n    pieceName = idDict[id[1].toLowerCase()];\n    offset = [kingLoc[0] - sqr[0], kingLoc[1] - sqr[1]];\n\n    if (strfind(pieceDefs[pieceName][getEnemyColor(color)][\"offsets\"], offset)) {\n      boardFilter4[rf] = boardFilter3[rf];\n    }\n  }\n\n  return mapListRfToXy(Object.keys(boardFilter4));\n} // module.exports = getOffsetThreats;\n\n/** for node.js\nif (require.main === module) {\n\n    import {sampleBoardDicts} from \"../testObjects/sampleBoardDicts\";\n    import {getStandardPieceDefs} from \"../testObjects/getStandardPieceDefs\";\n    import {getStandardIdDict} from \"../testObjects/getStandardIdDict\";\n    import {printBoard} from \"../printers/printBoard\";\n\n    var  pieceDefs, idDict, board;\n\n    pieceDefs = getStandardPieceDefs()\n    idDict = getStandardIdDict()\n\n    board = sampleBoardDicts[\"knight_threat2\"];\n    printBoard(board, heading=\"\\nknightThreat2, W\", mapListXyToRf(getOffsetThreats(board, [5, 1], \"W\", pieceDefs, idDict)))\n    printBoard(board, heading=\"\\nknightThreat2, B\", mapListXyToRf(getOffsetThreats(board, [7, 8], \"B\", pieceDefs, idDict)))\n    \n\n}\n*/","map":{"version":3,"sources":["/home/brian/ChessKingsCouncil/app/src/game_logic/threatArea/getOffsetThreats.js"],"names":["getPieceColor","getNextColor","getEnemyColor","strfind","rfToXy","mapListRfToXy","getOffsetThreats","board","kingLoc","color","pieceDefs","idDict","id","sqr","offset","pieceName","boardFilter1","boardFilter2","boardFilter3","boardFilter4","rf","Object","keys","toLowerCase"],"mappings":"AAAA,SAAQA,aAAR,QAA4B,wBAA5B;AACA,SAAQC,YAAY,IAAIC,aAAxB,QAA4C,uBAA5C;AACA,SAAQC,OAAR,QAAsB,oBAAtB;AACA,SAAQC,MAAR,QAAqB,uBAArB;AACA,SAAQC,aAAR,QAA4B,4BAA5B;AAEA,OAAO,SAASC,gBAAT,CAA0BC,KAA1B,EAAiCC,OAAjC,EAA0CC,KAA1C,EAAiDC,SAAjD,EAA4DC,MAA5D,EAAoE;AACvE;AAEA,MAAIC,EAAJ,EAAQC,GAAR,EAAaC,MAAb,EAAqBC,SAArB,EAAgCC,YAAhC,EAA8CC,YAA9C,EAA4DC,YAA5D,EAA0EC,YAA1E,CAHuE,CAKvE;;AACAH,EAAAA,YAAY,GAAG,EAAf;;AACA,OAAK,IAAII,EAAT,IAAeC,MAAM,CAACC,IAAP,CAAYf,KAAZ,CAAf,EAAmC;AAC/B,QAAIA,KAAK,CAACa,EAAD,CAAL,IAAa,GAAjB,EAAsB;AAClBJ,MAAAA,YAAY,CAACI,EAAD,CAAZ,GAAmBb,KAAK,CAACa,EAAD,CAAxB;AACH;AACJ,GAXsE,CAavE;;;AACAH,EAAAA,YAAY,GAAG,EAAf;;AACA,OAAK,IAAIG,EAAT,IAAeC,MAAM,CAACC,IAAP,CAAYN,YAAZ,CAAf,EAA0C;AACtC,QAAIhB,aAAa,CAACgB,YAAY,CAACI,EAAD,CAAb,CAAb,IAAmCX,KAAvC,EAA8C;AAC1CQ,MAAAA,YAAY,CAACG,EAAD,CAAZ,GAAmBJ,YAAY,CAACI,EAAD,CAA/B;AACH;AACJ,GAnBsE,CAqBvE;;;AACAF,EAAAA,YAAY,GAAG,EAAf;;AACA,OAAK,IAAIE,EAAT,IAAeC,MAAM,CAACC,IAAP,CAAYL,YAAZ,CAAf,EAA0C;AACtCL,IAAAA,EAAE,GAAGL,KAAK,CAACa,EAAD,CAAV;AACAL,IAAAA,SAAS,GAAGJ,MAAM,CAACC,EAAE,CAAC,CAAD,CAAF,CAAMW,WAAN,EAAD,CAAlB;;AACA,QAAIR,SAAS,IAAI,MAAb,IAAwBA,SAAS,IAAI,MAAzC,EAAiD;AAC7CG,MAAAA,YAAY,CAACE,EAAD,CAAZ,GAAmBH,YAAY,CAACG,EAAD,CAA/B;AACH;AACJ,GA7BsE,CA+BvE;;;AACAD,EAAAA,YAAY,GAAG,EAAf;;AACA,OAAK,IAAIC,EAAT,IAAeC,MAAM,CAACC,IAAP,CAAYJ,YAAZ,CAAf,EAA0C;AACtCN,IAAAA,EAAE,GAAGL,KAAK,CAACa,EAAD,CAAV;AACAP,IAAAA,GAAG,GAAGT,MAAM,CAACgB,EAAD,CAAZ;AACAL,IAAAA,SAAS,GAAGJ,MAAM,CAACC,EAAE,CAAC,CAAD,CAAF,CAAMW,WAAN,EAAD,CAAlB;AACAT,IAAAA,MAAM,GAAG,CAACN,OAAO,CAAC,CAAD,CAAP,GAAaK,GAAG,CAAC,CAAD,CAAjB,EAAsBL,OAAO,CAAC,CAAD,CAAP,GAAaK,GAAG,CAAC,CAAD,CAAtC,CAAT;;AACA,QAAIV,OAAO,CAACO,SAAS,CAACK,SAAD,CAAT,CAAqBb,aAAa,CAACO,KAAD,CAAlC,EAA2C,SAA3C,CAAD,EAAwDK,MAAxD,CAAX,EAA4E;AACxEK,MAAAA,YAAY,CAACC,EAAD,CAAZ,GAAmBF,YAAY,CAACE,EAAD,CAA/B;AACH;AACJ;;AAED,SAAOf,aAAa,CAACgB,MAAM,CAACC,IAAP,CAAYH,YAAZ,CAAD,CAApB;AACH,C,CAED;;AAEA","sourcesContent":["import {getPieceColor} from \"../color/getPieceColor\";\nimport {getNextColor as getEnemyColor} from \"../color/getNextColor\";\nimport {strfind} from \"../helpers/strfind\";\nimport {rfToXy} from \"../coordType/crdCnvrt\";\nimport {mapListRfToXy} from \"../coordType/mapListRfToXy\";\n\nexport function getOffsetThreats(board, kingLoc, color, pieceDefs, idDict) {\n    /* **/\n\n    var id, sqr, offset, pieceName, boardFilter1, boardFilter2, boardFilter3, boardFilter4;\n\n    //filter out empty squares\n    boardFilter1 = {}\n    for (var rf of Object.keys(board)) {\n        if (board[rf] != '#') {\n            boardFilter1[rf] = board[rf]\n        }\n    }\n\n    //only include piece if not the same color\n    boardFilter2 = {}\n    for (var rf of Object.keys(boardFilter1)) {\n        if (getPieceColor(boardFilter1[rf]) != color) {\n            boardFilter2[rf] = boardFilter1[rf]\n        }\n    }\n\n    //filter out King and Pawn (special pieces)\n    boardFilter3 = {}\n    for (var rf of Object.keys(boardFilter2)) {\n        id = board[rf]\n        pieceName = idDict[id[1].toLowerCase()]\n        if (pieceName != \"King\" &&  pieceName != \"Pawn\") {\n            boardFilter3[rf] = boardFilter2[rf]\n        }\n    }\n\n    //only include pieces that have offsets that hit the king, as part of their range\n    boardFilter4 = {}\n    for (var rf of Object.keys(boardFilter3)) {\n        id = board[rf]\n        sqr = rfToXy(rf)\n        pieceName = idDict[id[1].toLowerCase()]\n        offset = [kingLoc[0] - sqr[0], kingLoc[1] - sqr[1]]\n        if (strfind(pieceDefs[pieceName][getEnemyColor(color)][\"offsets\"], offset)) {\n            boardFilter4[rf] = boardFilter3[rf]\n        }\n    }\n\n    return mapListRfToXy(Object.keys(boardFilter4))\n}\n\n// module.exports = getOffsetThreats;\n\n/** for node.js\nif (require.main === module) {\n\n    import {sampleBoardDicts} from \"../testObjects/sampleBoardDicts\";\n    import {getStandardPieceDefs} from \"../testObjects/getStandardPieceDefs\";\n    import {getStandardIdDict} from \"../testObjects/getStandardIdDict\";\n    import {printBoard} from \"../printers/printBoard\";\n\n    var  pieceDefs, idDict, board;\n\n    pieceDefs = getStandardPieceDefs()\n    idDict = getStandardIdDict()\n\n    board = sampleBoardDicts[\"knight_threat2\"];\n    printBoard(board, heading=\"\\nknightThreat2, W\", mapListXyToRf(getOffsetThreats(board, [5, 1], \"W\", pieceDefs, idDict)))\n    printBoard(board, heading=\"\\nknightThreat2, B\", mapListXyToRf(getOffsetThreats(board, [7, 8], \"B\", pieceDefs, idDict)))\n    \n\n}\n*/"]},"metadata":{},"sourceType":"module"}