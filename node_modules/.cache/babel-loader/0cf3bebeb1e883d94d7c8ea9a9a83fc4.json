{"ast":null,"code":"import { rfToXy, xyToRf } from \"../coordType/crdCnvrt\";\nimport { mapDictListRfToXy } from \"../coordType/mapDictListRfToXy\";\nimport { mapDictListXyToRf } from \"../coordType/mapDictListXyToRf\";\nimport { getPieceType } from \"../pieceType/getPieceType\";\nexport class JsonRecords {\n  /*contains the necessary info to determine when castles and en-passants can be performed**/\n  constructor(records) {\n    /*new instance of object created for every update to piece finalRanges i.e. @app.update()**/\n    this.rooksMoved = records['rooks_moved'];\n    this.kingsMoved = records['kings_moved'];\n    this.pawnHistories = records['pawn_histories'];\n    this.lastPawnMove = records['last_pawn_move'];\n    this.numConsecutiveNonPawnMoves = records['num_consecutive_non_pawn_moves'];\n  }\n\n  pawnKeysToCurrentRf() {\n    /*swap the key of each pawnHistory entry with the coordinate of its current location**/\n    var pawnHistories = {};\n\n    for (var hist of Object.values(this.pawnHistories)) {\n      let sqr = hist[hist.length - 1];\n      pawnHistories[sqr] = hist;\n    }\n\n    this.pawnHistories = pawnHistories;\n  }\n\n  update(id, start, dest, promoFlag) {\n    /*update json records depending on the piece type of id_ at location start**/\n    var pType = getPieceType(id);\n\n    if (pType != \"P\") {\n      this.numConsecutiveNonPawnMoves += 1;\n\n      if (pType === 'R' && Object.keys(this.rooksMoved).includes(start)) {\n        this.updateRooksMoved(start);\n      } else if (pType === 'K' && Object.keys(this.kingsMoved).includes(start)) {\n        this.updateKingsMoved(start);\n      }\n    } else {\n      this.resetNonPawnMoves();\n      this.lastPawnMove = dest;\n      this.updatePawnHistory(id, dest, promoFlag);\n    }\n\n    return;\n  }\n\n  updateRooksMoved(sqr) {\n    /*update rooksMoved because rook that start game at sqr has moved**/\n    this.rooksMoved[sqr] = true;\n  }\n\n  updateKingsMoved(sqr) {\n    /*update kingsMoved because king that started game at sqr has moved**/\n    this.kingsMoved[sqr] = true;\n  }\n\n  updatePawnHistory(id_, newLoc, promo) {\n    /*update location of pawn by appending its new location to its history**/\n    console.log(\"id\", id_);\n    console.log(\"newLoc\", newLoc);\n    console.log(\"promo\", promo);\n\n    if (promo) {\n      delete this.pawnHistories[id_];\n    } else {\n      this.pawnHistories[id_].push(newLoc);\n    }\n  }\n\n  getMapRecords() {\n    /**convert pawnHistories and last_pawn_move to rankfile format, than return all records */\n    this.pawnHistories = mapDictListXyToRf(this.pawnHistories);\n    this.lastPawnMove = xyToRf(...this.lastPawnMove);\n    return this.getRecords();\n  }\n\n  getRecords() {\n    /*return the json records as one python dict**/\n    return {\n      rooks_moved: this.rooksMoved,\n      kings_moved: this.kingsMoved,\n      pawn_histories: this.pawnHistories,\n      last_pawn_move: this.lastPawnMove,\n      num_consecutive_non_pawn_moves: this.numConsecutiveNonPawnMoves\n    };\n  }\n\n  resetNonPawnMoves() {\n    /* a pawn has just moved, so reset number of consecutive non pawn moves to 0**/\n    this.numConsecutiveNonPawnMoves = 0;\n  }\n\n  deletePawn(id) {\n    /*delete pawn with id from pawn histories**/\n    delete this.pawnHistories[id];\n  }\n\n  hasKingMoved(color) {\n    /*return true/false of if the King of color has moved from its starting position**/\n    if (color === 'W') {\n      return this.kingsMoved[\"e1\"];\n    } else if (color === 'B') {\n      return this.kingsMoved[\"e8\"];\n    } else {\n      console.log('error: ! a valid color\\n');\n      return -1;\n    }\n  }\n\n  getStartKing(color) {\n    /*get starting position of king based off of color**/\n    if (color === 'W') {\n      return \"e1\";\n    } else if (color === 'B') {\n      return \"e8\";\n    } else {\n      console.log('error:invalid color');\n      return -1;\n    }\n  }\n\n  updateRookDict(rooksMoved) {\n    /*update rooksMoved dict to a new one**/\n    this.rooksMoved = rooksMoved;\n  }\n\n  queenSideRookMoved(color) {\n    /*return true if the queen side rook of the given color has moved, otherwise false**/\n    if (color === 'W') {\n      return this.rooksMoved[\"a1\"];\n    } else if (color === 'B') {\n      return this.rooksMoved[\"a8\"];\n    }\n  }\n\n  kingSideRookMoved(color) {\n    /*return true if the king side rook of the given color has moved, otherwise false**/\n    if (color === 'W') {\n      return this.rooksMoved[\"h1\"];\n    } else if (color === 'B') {\n      return this.rooksMoved[\"h8\"];\n    }\n  }\n\n  isLastPawnMove(rf) {\n    if (rf === this.lastPawnMove) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n} // module.exports = JsonRecords;\n\n/** for node.js\nif (require.main === module) {\n\n    import {sampleBoardDicts} from \"../testObjects/sampleBoardDicts\";\n    import {dataDict} from \"../testObjects/dataDicts/dd1\";\n\n    var records = dataDict[\"pawn_range\"][\"json\"]\n    var board = sampleBoardDicts[\"pawn_range\"];\n\n}\n*/","map":{"version":3,"sources":["/home/brian/ChessKingsCouncil/app/src/game_logic/JsonRecords/JsonRecords.js"],"names":["rfToXy","xyToRf","mapDictListRfToXy","mapDictListXyToRf","getPieceType","JsonRecords","constructor","records","rooksMoved","kingsMoved","pawnHistories","lastPawnMove","numConsecutiveNonPawnMoves","pawnKeysToCurrentRf","hist","Object","values","sqr","length","update","id","start","dest","promoFlag","pType","keys","includes","updateRooksMoved","updateKingsMoved","resetNonPawnMoves","updatePawnHistory","id_","newLoc","promo","console","log","push","getMapRecords","getRecords","rooks_moved","kings_moved","pawn_histories","last_pawn_move","num_consecutive_non_pawn_moves","deletePawn","hasKingMoved","color","getStartKing","updateRookDict","queenSideRookMoved","kingSideRookMoved","isLastPawnMove","rf"],"mappings":"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","sourcesContent":["import {rfToXy, xyToRf} from \"../coordType/crdCnvrt\";\nimport {mapDictListRfToXy} from \"../coordType/mapDictListRfToXy\";\nimport { mapDictListXyToRf } from \"../coordType/mapDictListXyToRf\";\nimport {getPieceType} from \"../pieceType/getPieceType\";\n\n\nexport class JsonRecords {\n    /*contains the necessary info to determine when castles and en-passants can be performed**/\n\n    constructor(records) {\n        /*new instance of object created for every update to piece finalRanges i.e. @app.update()**/\n        this.rooksMoved = records['rooks_moved']\n        this.kingsMoved = records['kings_moved']\n        this.pawnHistories = records['pawn_histories']\n        this.lastPawnMove = records['last_pawn_move']\n        this.numConsecutiveNonPawnMoves = records['num_consecutive_non_pawn_moves']\n    }\n\n    pawnKeysToCurrentRf() {\n        /*swap the key of each pawnHistory entry with the coordinate of its current location**/\n        var pawnHistories = {}\n        for (var hist of Object.values(this.pawnHistories)) {\n            let sqr = hist[hist.length - 1]\n            pawnHistories[sqr] = hist\n        }\n        this.pawnHistories = pawnHistories\n    }\n\n    update(id, start, dest, promoFlag) {\n        /*update json records depending on the piece type of id_ at location start**/\n        var pType = getPieceType(id);\n        if (pType != \"P\") {\n            this.numConsecutiveNonPawnMoves += 1\n            if (pType === 'R' &&  Object.keys(this.rooksMoved).includes(start)) {\n                this.updateRooksMoved(start)\n            }\n            else if (pType === 'K' &&  Object.keys(this.kingsMoved).includes(start)) {\n                this.updateKingsMoved(start)\n            }\n        }\n        else {\n            this.resetNonPawnMoves()\n            this.lastPawnMove = dest\n            this.updatePawnHistory(id, dest, promoFlag)\n        }\n        return\n    }\n\n    updateRooksMoved(sqr) {\n        /*update rooksMoved because rook that start game at sqr has moved**/\n        this.rooksMoved[sqr] = true\n    }\n\n    updateKingsMoved(sqr) {\n        /*update kingsMoved because king that started game at sqr has moved**/\n        this.kingsMoved[sqr] = true\n    }\n\n    updatePawnHistory(id_, newLoc, promo) {\n        /*update location of pawn by appending its new location to its history**/\n        console.log(\"id\", id_)\n        console.log(\"newLoc\", newLoc)\n        console.log(\"promo\", promo)\n        if (promo) {\n            delete this.pawnHistories[id_]\n        }\n        else {\n            this.pawnHistories[id_].push(newLoc)\n        }\n    }\n\n    getMapRecords() {\n        /**convert pawnHistories and last_pawn_move to rankfile format, than return all records */\n        this.pawnHistories = mapDictListXyToRf(this.pawnHistories)\n        this.lastPawnMove = xyToRf(...this.lastPawnMove)\n        return this.getRecords()\n    }\n\n    getRecords() {\n        /*return the json records as one python dict**/\n        return {\n            rooks_moved: this.rooksMoved,\n            kings_moved: this.kingsMoved,\n            pawn_histories: this.pawnHistories,\n            last_pawn_move: this.lastPawnMove,\n            num_consecutive_non_pawn_moves: this.numConsecutiveNonPawnMoves,\n        };\n    }\n\n    resetNonPawnMoves() {\n        /* a pawn has just moved, so reset number of consecutive non pawn moves to 0**/\n        this.numConsecutiveNonPawnMoves = 0\n    }\n\n    deletePawn(id) {\n        /*delete pawn with id from pawn histories**/\n        delete this.pawnHistories[id]\n    }\n\n    hasKingMoved(color) {\n        /*return true/false of if the King of color has moved from its starting position**/\n        if (color === 'W') {\n            return this.kingsMoved[\"e1\"]\n        }\n        else if (color === 'B') {\n            return this.kingsMoved[\"e8\"]\n        }\n        else {\n            console.log('error: ! a valid color\\n')\n            return -1\n        }\n    }\n\n    getStartKing(color) {\n        /*get starting position of king based off of color**/\n        if (color === 'W') {\n            return \"e1\"\n        }\n        else if (color === 'B') {\n            return \"e8\"\n        }\n        else {\n            console.log('error:invalid color')\n            return -1\n        }\n    }\n\n    updateRookDict(rooksMoved) {\n        /*update rooksMoved dict to a new one**/\n        this.rooksMoved = rooksMoved\n    }\n\n    queenSideRookMoved(color) {\n        /*return true if the queen side rook of the given color has moved, otherwise false**/\n        if (color === 'W') {\n            return this.rooksMoved[\"a1\"]\n        }\n        else if (color === 'B') {\n            return this.rooksMoved[\"a8\"]\n        }\n    }\n\n    kingSideRookMoved(color) {\n        /*return true if the king side rook of the given color has moved, otherwise false**/\n        if (color === 'W') {\n            return this.rooksMoved[\"h1\"]\n        }\n        else if (color === 'B') {\n            return this.rooksMoved[\"h8\"]\n        }\n    }\n\n    isLastPawnMove(rf) {\n        if (rf === this.lastPawnMove) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n}\n\n// module.exports = JsonRecords;\n\n/** for node.js\nif (require.main === module) {\n\n    import {sampleBoardDicts} from \"../testObjects/sampleBoardDicts\";\n    import {dataDict} from \"../testObjects/dataDicts/dd1\";\n\n    var records = dataDict[\"pawn_range\"][\"json\"]\n    var board = sampleBoardDicts[\"pawn_range\"];\n\n}\n*/"]},"metadata":{},"sourceType":"module"}