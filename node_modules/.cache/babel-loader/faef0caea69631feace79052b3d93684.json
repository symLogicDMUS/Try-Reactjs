{"ast":null,"code":"import { isEnpBlackAttR } from \"./isEnpBlackAttR\";\nimport { isEnpWhiteAttR } from \"./isEnpWhiteAttR\";\nimport { pawnMovedOnce2Sqrs } from \"./pawnMovedOnce2Sqrs\";\nimport { getPieceType } from \"../../../pieceType/getPieceType\";\nimport { getSqrCase } from \"../../../sqrCase/getSqrCase\";\nimport { ENEMY } from \"../../../sqrCase/sqrCases\";\nimport { xyToRf, rfToXy } from \"../../../coordType/crdCnvrt\";\nimport { JsonRecords } from \"../../../JsonRecords/JsonRecords\";\nimport { replaceRankfileWithPawnId } from \"../../../JsonRecords/replaceRankfileWithPawnId\";\nexport function canEnpassant(attacking, attacked, board, color, pawnHistories, ncnpm, lastPawnMove) {\n  /**return true if an en-passant can be performed given sqr1 &&  sqr2 alignment, else false\n     ncnpm: Number Consecutive Non Pawn Moves\n  */\n  if (color === 'W' && !isEnpWhiteAttR(attacking)) {\n    return false;\n  }\n\n  if (color === 'B' && !isEnpBlackAttR(attacking)) {\n    return false;\n  }\n\n  if (getSqrCase(board, attacked[0], attacked[1], color) != ENEMY) {\n    return false;\n  }\n\n  if (getPieceType(board[xyToRf(...attacked)]) != 'P') {\n    return false;\n  }\n\n  if (ncnpm != 0) {\n    return false;\n  }\n\n  if (!pawnMovedOnce2Sqrs(pawnHistories, board[xyToRf(...attacked)])) {\n    return false;\n  }\n\n  if (xyToRf(...attacked) != lastPawnMove) {\n    return false;\n  }\n\n  return true;\n} // module.exports = canEnpassant;\n\n/** for node.js\nif (require.main === module) {\n    // test 1, enPassantTest1:\n    \n    import {sampleBoardDicts} from \"../../../testObjects/sampleBoardDicts\"\n    import {dataDict} from \"../../../testObjects/dataDicts/dd1\";\n    import {printBoard} from \"../../../printers/printBoard\";\n    import {step_1sqr180d} from \"../../../helpers/stepFuncs\";\n    import {initPawnIds} from \"../../../JsonRecords/initPawnIds\";\n    var board, records, jsonRecords;\n\n    board = sampleBoardDicts[\"enpassant_test1\"];\n    records = dataDict[\"enpassant_test1\"][\"json\"]\n\n    jsonRecords = new JsonRecords(initPawnIds(records, board))\n    for (var rf of Object.keys(board)) {\n        if (getPieceType(board[rf]) === \"P\") {\n            if (\n                canEnpassant(\n                    rfToXy(rf),\n                    step_1sqr180d(...rfToXy(rf)),\n                    board,\n                    \"W\",\n                    jsonRecords.pawnHistories,\n                    jsonRecords.numConsecutiveNonPawnMoves,\n                    jsonRecords.lastPawnMove\n                )\n            ) {\n                printBoard(board, \"red: attacking, green: attacked\", [rf], [xyToRf(...step_1sqr180d(...rfToXy(rf)))] );\n            }\n        }\n    }\n\n    //console.log(canEnpassant([3, 5], [2, 5], board, 'W', jsonRecords.pawnHistories, jsonRecords.numConsecutiveNonPawnMoves, jsonRecords.lastPawnMove))\n\n}\n*/","map":{"version":3,"sources":["/home/brian/ChessKingsCouncil/app/src/game_logic/ranges/specialMoves/enPassant/canEnPassant.js"],"names":["isEnpBlackAttR","isEnpWhiteAttR","pawnMovedOnce2Sqrs","getPieceType","getSqrCase","ENEMY","xyToRf","rfToXy","JsonRecords","replaceRankfileWithPawnId","canEnpassant","attacking","attacked","board","color","pawnHistories","ncnpm","lastPawnMove"],"mappings":"AAAA,SAAQA,cAAR,QAA6B,kBAA7B;AACA,SAAQC,cAAR,QAA6B,kBAA7B;AACA,SAAQC,kBAAR,QAAiC,sBAAjC;AACA,SAAQC,YAAR,QAA2B,iCAA3B;AACA,SAAQC,UAAR,QAAyB,6BAAzB;AACA,SAAQC,KAAR,QAAoB,2BAApB;AACA,SAAQC,MAAR,EAAgBC,MAAhB,QAA6B,6BAA7B;AACA,SAAQC,WAAR,QAA0B,kCAA1B;AACA,SAAQC,yBAAR,QAAwC,gDAAxC;AAGA,OAAO,SAASC,YAAT,CAAsBC,SAAtB,EAAiCC,QAAjC,EAA2CC,KAA3C,EAAkDC,KAAlD,EAAyDC,aAAzD,EAAwEC,KAAxE,EAA+EC,YAA/E,EAA6F;AAChG;;;AAGA,MAAIH,KAAK,KAAK,GAAV,IAAkB,CAAEb,cAAc,CAACU,SAAD,CAAtC,EAAmD;AAC/C,WAAO,KAAP;AACH;;AACD,MAAIG,KAAK,KAAK,GAAV,IAAkB,CAAEd,cAAc,CAACW,SAAD,CAAtC,EAAmD;AAC/C,WAAO,KAAP;AACH;;AACD,MAAIP,UAAU,CAACS,KAAD,EAAQD,QAAQ,CAAC,CAAD,CAAhB,EAAqBA,QAAQ,CAAC,CAAD,CAA7B,EAAkCE,KAAlC,CAAV,IAAsDT,KAA1D,EAAiE;AAC7D,WAAO,KAAP;AACH;;AACD,MAAIF,YAAY,CAACU,KAAK,CAACP,MAAM,CAAC,GAAGM,QAAJ,CAAP,CAAN,CAAZ,IAA4C,GAAhD,EAAqD;AACjD,WAAO,KAAP;AACH;;AACD,MAAII,KAAK,IAAI,CAAb,EAAgB;AACZ,WAAO,KAAP;AACH;;AACD,MAAI,CAAEd,kBAAkB,CAACa,aAAD,EAAgBF,KAAK,CAACP,MAAM,CAAC,GAAGM,QAAJ,CAAP,CAArB,CAAxB,EAAqE;AACjE,WAAO,KAAP;AACH;;AACD,MAAIN,MAAM,CAAC,GAAGM,QAAJ,CAAN,IAAuBK,YAA3B,EAAyC;AACrC,WAAO,KAAP;AACH;;AACD,SAAO,IAAP;AACH,C,CAED;;AAGA","sourcesContent":["import {isEnpBlackAttR} from \"./isEnpBlackAttR\";\nimport {isEnpWhiteAttR} from \"./isEnpWhiteAttR\";\nimport {pawnMovedOnce2Sqrs} from \"./pawnMovedOnce2Sqrs\" \nimport {getPieceType} from \"../../../pieceType/getPieceType\";\nimport {getSqrCase} from \"../../../sqrCase/getSqrCase\";\nimport {ENEMY} from \"../../../sqrCase/sqrCases\";\nimport {xyToRf, rfToXy} from \"../../../coordType/crdCnvrt\";\nimport {JsonRecords} from \"../../../JsonRecords/JsonRecords\";\nimport {replaceRankfileWithPawnId} from \"../../../JsonRecords/replaceRankfileWithPawnId\";\n\n\nexport function canEnpassant(attacking, attacked, board, color, pawnHistories, ncnpm, lastPawnMove) {\n    /**return true if an en-passant can be performed given sqr1 &&  sqr2 alignment, else false\n       ncnpm: Number Consecutive Non Pawn Moves\n    */\n    if (color === 'W' &&  ! isEnpWhiteAttR(attacking)) {\n        return false\n    }\n    if (color === 'B' &&  ! isEnpBlackAttR(attacking)) {\n        return false\n    }\n    if (getSqrCase(board, attacked[0], attacked[1], color) != ENEMY) {\n        return false\n    }\n    if (getPieceType(board[xyToRf(...attacked)]) != 'P') {\n        return false\n    }\n    if (ncnpm != 0) {\n        return false\n    }\n    if (! pawnMovedOnce2Sqrs(pawnHistories, board[xyToRf(...attacked)])) {\n        return false\n    }\n    if (xyToRf(...attacked) != lastPawnMove) {\n        return false\n    }\n    return true\n}\n\n// module.exports = canEnpassant;\n\n\n/** for node.js\nif (require.main === module) {\n    // test 1, enPassantTest1:\n    \n    import {sampleBoardDicts} from \"../../../testObjects/sampleBoardDicts\"\n    import {dataDict} from \"../../../testObjects/dataDicts/dd1\";\n    import {printBoard} from \"../../../printers/printBoard\";\n    import {step_1sqr180d} from \"../../../helpers/stepFuncs\";\n    import {initPawnIds} from \"../../../JsonRecords/initPawnIds\";\n    var board, records, jsonRecords;\n\n    board = sampleBoardDicts[\"enpassant_test1\"];\n    records = dataDict[\"enpassant_test1\"][\"json\"]\n\n    jsonRecords = new JsonRecords(initPawnIds(records, board))\n    for (var rf of Object.keys(board)) {\n        if (getPieceType(board[rf]) === \"P\") {\n            if (\n                canEnpassant(\n                    rfToXy(rf),\n                    step_1sqr180d(...rfToXy(rf)),\n                    board,\n                    \"W\",\n                    jsonRecords.pawnHistories,\n                    jsonRecords.numConsecutiveNonPawnMoves,\n                    jsonRecords.lastPawnMove\n                )\n            ) {\n                printBoard(board, \"red: attacking, green: attacked\", [rf], [xyToRf(...step_1sqr180d(...rfToXy(rf)))] );\n            }\n        }\n    }\n\n    //console.log(canEnpassant([3, 5], [2, 5], board, 'W', jsonRecords.pawnHistories, jsonRecords.numConsecutiveNonPawnMoves, jsonRecords.lastPawnMove))\n\n}\n*/"]},"metadata":{},"sourceType":"module"}