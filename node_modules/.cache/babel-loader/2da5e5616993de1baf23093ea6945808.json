{"ast":null,"code":"import { mapListXyToRf } from \"../../coordType/mapListXyToRf\";\nimport { mapListListXyToRf } from \"../../coordType/mapListListXyToRf\";\nimport { strfind } from \"../../helpers/strfind\";\nimport { replacePawnIdWithRankfile } from \"../../JsonRecords/replacePawnIdWithRankfile\";\nimport { filterNonMatchingRows } from \"./pawnPromotion/filterNonMatchingRows\";\nimport { getPawnIds } from \"./pawnPromotion/getPawnIds\";\nimport { getPawnRanges } from \"./pawnPromotion/getPawnRanges\";\nimport { getPromos } from \"./pawnPromotion/getPromos\";\nimport { isPromoRows } from \"./pawnPromotion/isPromoRows\";\nimport { xyToRf } from \"../../coordType/crdCnvrt\";\nexport class SpecialMoves {\n  /*records the moves of current turn that are en-passant, castle, || pawn promotion**/\n  constructor(moves) {\n    /* **/\n    if (moves) {\n      this.enPassant = moves['en_passant'];\n      this.castles = moves['castles'];\n      this.promos = moves['promos'];\n    } else {\n      this.enPassant = [];\n      this.castles = [];\n      this.promos = [];\n    } //will be the location of a pawn that reached the back row and is about to be poromoted\n\n\n    this.pendingPromo = null;\n  }\n\n  update(moves) {\n    this.enPassant = moves['en_passant'];\n    this.castles = moves['castles'];\n    this.promos = moves['promos'];\n  }\n\n  convertToRf() {\n    this.enPassant = mapListListXyToRf(this.enPassant);\n    this.castles = mapListListXyToRf(this.castles);\n    this.promos = mapListListXyToRf(this.promos);\n    return;\n  }\n\n  isCastle(move) {\n    /*returns true if move is a currently available castle, otherwise false**/\n    if (strfind(this.castles, move)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  isPromo(move) {\n    /*returns true if move is a currently available pawn promotion, otherwise false**/\n    if (strfind(this.promos, move)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  isEnPassant(move) {\n    /*returns true if move is a currently available en-passant capture, otherwise false**/\n    if (strfind(this.enPassant, move)) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  addCastle(move) {\n    /*add move to currently available castles**/\n    this.castles.push(move);\n  }\n\n  addPromo(move) {\n    /*add move to list of currently avaliable pawn promotions**/\n    this.promos.push(move);\n  }\n\n  addEnPassant(move) {\n    /*add move to list of currently avaliable en-passants**/\n    this.enPassant.push(move);\n  }\n\n  getMoves() {\n    /*return castle, enPassant, &&  pawn promotion lists, as a dict**/\n    return {\n      'castles': this.castles,\n      'en_passant': this.enPassant,\n      'promos': this.promos\n    };\n  }\n\n  getCastles() {\n    /*return the list of castle moves**/\n    return this.castles;\n  }\n\n  getEnPassant() {\n    /*return the en-passant moves**/\n    return this.enPassant;\n  }\n\n  getPromos() {\n    /*return the pawn promotions**/\n    return this.promos;\n  }\n\n  setPromos(board, pawnLoc, pawnRange) {\n    for (var dest of pawnRange) {\n      if (isPromoRows(pawnLoc, dest, board[xyToRf(...pawnLoc)])) {\n        this.promos.push([pawnLoc, dest]);\n      }\n    }\n  }\n  /*\n  setPromos(board, ranges, color) {\n      // use the ranges &&  board to determine potential pawn promotions\n       ///getPawnIds\n      var pawnIds = getPawnIds(ranges, color)\n      \n      //getPawnRanges\n      var pawnRanges = getPawnRanges(pawnIds, ranges)\n       //setPawnRangeKeysToRf\n      var pawnRangesRfKey = replacePawnIdWithRankfile(board, pawnRanges)\n      \n      //filterNonMatchingRows\n      var promosDict = filterNonMatchingRows(board, pawnRangesRfKey)\n       //getPromos\n      this.promos = getPromos(promosDict);\n       return\n  }\n  */\n\n\n  removeCastle(move) {\n    let index = -1;\n\n    for (let i = 0; i < this.castles.length; i++) {\n      if (this.castles[i][0] === move[0] && this.castles[i][1] === move[1]) {\n        index = i;\n        break;\n      }\n    }\n\n    if (index > -1) {\n      this.castles.splice(index, 1);\n    }\n\n    return;\n  }\n\n  removePromo(move) {\n    let index = -1;\n\n    for (let i = 0; i < this.promos.length; i++) {\n      if (this.promos[i][0] === move[0] && this.promos[i][1] == move[1]) {\n        index = i;\n        break;\n      }\n    }\n\n    if (index > -1) {\n      this.promos.splice(index, 1);\n    }\n\n    return;\n  }\n\n  removeEnpassant(move) {\n    let index = -1;\n\n    for (let i = 0; i < this.enPassant.length; i++) {\n      if (this.enPassant[i][0] === move[0] && this.enPassant[i][1] === move[1]) {\n        index = i;\n        break;\n      }\n    }\n\n    if (index > -1) {\n      this.enPassant.splice(index, 1);\n    }\n  }\n\n} // module.exports = SpecialMoves;\n\n/** for node.js\nif (require.main === module) {\n    \n    import {sampleBoardDicts} from \"../../testObjects/sampleBoardDicts\";\n    import {mapListListXyToRf} from \"../../coordType/mapListListXyToRf\";\n    import {getPromoStartAndDest} from \"./pawnPromotion/getPromoStartAndDest\"\n    import {printBoard} from \"../../printers/printBoard\";\n\n    var specialMoves;\n\n    //THIS NEED TO BE CHANGED TO RANKFILE FORMAT RANGES AS specialMoves.setPromos() is called after getFinal Ranges!\n    var ranges =\n        {'WB1': [[7, 2], [8, 3], [5, 2], [4, 3], [3, 4], [2, 5], [1, 6]],\n         'WB2': [[6, 4], [7, 5], [8, 6], [4, 4], [3, 5], [2, 6], [1, 7], [4, 2], [3, 1]],\n         'WK1': [[4, 2], [5, 2]],\n         'WN1': [[5, 2], [6, 3], [8, 3]],\n         'WN2': [[2, 1], [3, 2], [3, 4], [2, 5]],\n         'WP1': [[6, 3], [6, 4]],\n         'WP2': [[8, 3], [8, 4]],\n         'WP3': [[1, 5]],\n         'WP4': [[6, 5]],\n         'WP5': [[7, 5], [8, 5], [6, 5]],\n         'WP6': [[2, 8], [3, 8], [1, 8]],\n         'WQ1': [[5, 2], [6, 3], [4, 2], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [3, 2], [3, 1], [2, 1]],\n         'WR1': [[1, 2], [2, 1], [3, 1]],\n         'WR2': [],\n         'BB1': [[2, 7]],\n         'BB2': [[5, 7], [4, 6], [3, 5], [2, 4], [1, 3]],\n         'BK1': [[5, 7], [6, 7]],\n         'BN1': [[2, 4], [4, 4], [1, 5], [1, 7], [5, 7], [2, 8]],\n         'BN2': [[6, 6], [8, 6], [5, 7]],\n         'BP1': [[3, 1], [4, 1]],\n         'BP2': [],\n         'BP3': [[6, 4], [5, 4], [7, 4]],\n         'BP4': [[8, 4], [7, 4]],\n         'BP5': [[4, 6], [4, 5]],\n         'BP6': [[7, 6], [7, 5]],\n         'BQ1': [[3, 7], [2, 6], [1, 5], [5, 7], [6, 6], [7, 5], [8, 4]],\n         'BR1': [[1, 7], [1, 6], [1, 5], [1, 4], [2, 8]],\n         'BR2': [[8, 7], [8, 6]]}\n    var board = sampleBoardDicts[\"pawnPromo\"];\n\n    specialMoves = new SpecialMoves()\n    specialMoves.setPromos(board, ranges, 'W')\n    var promos = mapListListXyToRf(specialMoves.promos)\n    var [promoStarts, promoDests] = getPromoStartAndDest(promos);\n    printBoard(board, \"white\", promoDests, null, promoStarts)\n\n    specialMoves = new SpecialMoves()\n    specialMoves.setPromos(board, ranges, 'B')\n    var promos = mapListListXyToRf(specialMoves.promos)\n    var [promoStarts, promoDests] = getPromoStartAndDest(promos);\n    printBoard(board, \"black\", promoDests, null, promoStarts)\n    \n\n}\n*/","map":{"version":3,"sources":["/home/brian/ChessKingsCouncil/app/src/game_logic/ranges/specialMoves/SpecialMoves.js"],"names":["mapListXyToRf","mapListListXyToRf","strfind","replacePawnIdWithRankfile","filterNonMatchingRows","getPawnIds","getPawnRanges","getPromos","isPromoRows","xyToRf","SpecialMoves","constructor","moves","enPassant","castles","promos","pendingPromo","update","convertToRf","isCastle","move","isPromo","isEnPassant","addCastle","push","addPromo","addEnPassant","getMoves","getCastles","getEnPassant","setPromos","board","pawnLoc","pawnRange","dest","removeCastle","index","i","length","splice","removePromo","removeEnpassant"],"mappings":"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","sourcesContent":["import { mapListXyToRf } from \"../../coordType/mapListXyToRf\";\nimport { mapListListXyToRf } from \"../../coordType/mapListListXyToRf\";\nimport {strfind} from \"../../helpers/strfind\";\nimport {replacePawnIdWithRankfile} from \"../../JsonRecords/replacePawnIdWithRankfile\";\nimport {filterNonMatchingRows} from \"./pawnPromotion/filterNonMatchingRows\";\nimport {getPawnIds} from \"./pawnPromotion/getPawnIds\";\nimport {getPawnRanges} from \"./pawnPromotion/getPawnRanges\";\nimport {getPromos} from \"./pawnPromotion/getPromos\"\nimport { isPromoRows } from \"./pawnPromotion/isPromoRows\";\nimport { xyToRf } from \"../../coordType/crdCnvrt\";\n\n\nexport class SpecialMoves {\n    /*records the moves of current turn that are en-passant, castle, || pawn promotion**/\n\n    constructor(moves) {\n        /* **/\n        if (moves) {\n            this.enPassant = moves['en_passant']\n            this.castles = moves['castles']\n            this.promos = moves['promos']\n        }\n        else {\n            this.enPassant = []\n            this.castles = []\n            this.promos = []\n        }\n\n        //will be the location of a pawn that reached the back row and is about to be poromoted\n        this.pendingPromo = null;\n\n    }\n\n    update(moves) {\n        this.enPassant = moves['en_passant']\n        this.castles = moves['castles']\n        this.promos = moves['promos']\n    }\n\n    convertToRf() {\n        this.enPassant = mapListListXyToRf(this.enPassant)\n        this.castles = mapListListXyToRf(this.castles)\n        this.promos = mapListListXyToRf(this.promos)\n        return\n    }\n\n    isCastle(move) {\n        /*returns true if move is a currently available castle, otherwise false**/\n        if (strfind(this.castles, move)) {\n            return true\n        }\n        else {\n            return false\n        }\n    }\n\n    isPromo(move) {\n        /*returns true if move is a currently available pawn promotion, otherwise false**/\n        if (strfind(this.promos, move)) {\n            return true\n        }\n        else {\n            return false\n        }\n    }\n\n    isEnPassant(move) {\n        /*returns true if move is a currently available en-passant capture, otherwise false**/\n        if (strfind(this.enPassant, move)) {\n            return true\n        }\n        else {\n            return false\n        }\n    }\n\n    addCastle(move) {\n        /*add move to currently available castles**/\n        this.castles.push(move)\n    }\n    \n    addPromo(move) {\n        /*add move to list of currently avaliable pawn promotions**/\n        this.promos.push(move)\n    }\n\n    addEnPassant(move) {\n        /*add move to list of currently avaliable en-passants**/\n        this.enPassant.push(move)\n    }\n\n    getMoves() {\n        /*return castle, enPassant, &&  pawn promotion lists, as a dict**/\n        return {'castles': this.castles, 'en_passant': this.enPassant, 'promos': this.promos}\n    }\n\n    getCastles() {\n        /*return the list of castle moves**/\n        return this.castles\n    }\n\n    getEnPassant() {\n        /*return the en-passant moves**/\n        return this.enPassant\n    }\n\n    getPromos() {\n        /*return the pawn promotions**/\n        return this.promos\n    }\n\n    setPromos(board, pawnLoc, pawnRange) {\n        for (var dest of pawnRange) {\n            if ( isPromoRows(pawnLoc, dest, board[xyToRf(...pawnLoc)]) ) {\n                this.promos.push([pawnLoc, dest])\n            }\n        }\n    }\n\n    /*\n    setPromos(board, ranges, color) {\n        // use the ranges &&  board to determine potential pawn promotions\n\n        ///getPawnIds\n        var pawnIds = getPawnIds(ranges, color)\n        \n        //getPawnRanges\n        var pawnRanges = getPawnRanges(pawnIds, ranges)\n\n        //setPawnRangeKeysToRf\n        var pawnRangesRfKey = replacePawnIdWithRankfile(board, pawnRanges)\n        \n        //filterNonMatchingRows\n        var promosDict = filterNonMatchingRows(board, pawnRangesRfKey)\n\n        //getPromos\n        this.promos = getPromos(promosDict);\n\n        return\n    }\n    */\n   \n    removeCastle(move) {\n        let index = -1;\n        for (let i = 0; i < this.castles.length; i++) {\n            if (this.castles[i][0] === move[0] && this.castles[i][1] === move[1]) {\n                index = i;\n                break;\n            }\n        }\n        if (index > -1) {\n            this.castles.splice(index, 1)\n        }\n        return\n    }\n\n    removePromo(move) {\n        let index = -1;\n        for (let i = 0; i < this.promos.length; i++) {\n            if (this.promos[i][0] === move[0] && this.promos[i][1] == move[1]) {\n                index = i;\n                break;\n            }\n        }\n        if (index > -1) {\n            this.promos.splice(index, 1)\n        }\n        return\n    }\n\n    removeEnpassant(move) {\n        let index = -1;\n        for (let i = 0; i < this.enPassant.length; i++) {\n            if (this.enPassant[i][0] === move[0] && this.enPassant[i][1] === move[1]) {\n                index = i;\n                break;\n            }\n        }\n        if (index > -1) {\n            this.enPassant.splice(index, 1)\n        }\n    }\n    \n}\n\n// module.exports = SpecialMoves;\n\n/** for node.js\nif (require.main === module) {\n    \n    import {sampleBoardDicts} from \"../../testObjects/sampleBoardDicts\";\n    import {mapListListXyToRf} from \"../../coordType/mapListListXyToRf\";\n    import {getPromoStartAndDest} from \"./pawnPromotion/getPromoStartAndDest\"\n    import {printBoard} from \"../../printers/printBoard\";\n\n    var specialMoves;\n\n    //THIS NEED TO BE CHANGED TO RANKFILE FORMAT RANGES AS specialMoves.setPromos() is called after getFinal Ranges!\n    var ranges =\n        {'WB1': [[7, 2], [8, 3], [5, 2], [4, 3], [3, 4], [2, 5], [1, 6]],\n         'WB2': [[6, 4], [7, 5], [8, 6], [4, 4], [3, 5], [2, 6], [1, 7], [4, 2], [3, 1]],\n         'WK1': [[4, 2], [5, 2]],\n         'WN1': [[5, 2], [6, 3], [8, 3]],\n         'WN2': [[2, 1], [3, 2], [3, 4], [2, 5]],\n         'WP1': [[6, 3], [6, 4]],\n         'WP2': [[8, 3], [8, 4]],\n         'WP3': [[1, 5]],\n         'WP4': [[6, 5]],\n         'WP5': [[7, 5], [8, 5], [6, 5]],\n         'WP6': [[2, 8], [3, 8], [1, 8]],\n         'WQ1': [[5, 2], [6, 3], [4, 2], [4, 3], [4, 4], [4, 5], [4, 6], [4, 7], [3, 2], [3, 1], [2, 1]],\n         'WR1': [[1, 2], [2, 1], [3, 1]],\n         'WR2': [],\n         'BB1': [[2, 7]],\n         'BB2': [[5, 7], [4, 6], [3, 5], [2, 4], [1, 3]],\n         'BK1': [[5, 7], [6, 7]],\n         'BN1': [[2, 4], [4, 4], [1, 5], [1, 7], [5, 7], [2, 8]],\n         'BN2': [[6, 6], [8, 6], [5, 7]],\n         'BP1': [[3, 1], [4, 1]],\n         'BP2': [],\n         'BP3': [[6, 4], [5, 4], [7, 4]],\n         'BP4': [[8, 4], [7, 4]],\n         'BP5': [[4, 6], [4, 5]],\n         'BP6': [[7, 6], [7, 5]],\n         'BQ1': [[3, 7], [2, 6], [1, 5], [5, 7], [6, 6], [7, 5], [8, 4]],\n         'BR1': [[1, 7], [1, 6], [1, 5], [1, 4], [2, 8]],\n         'BR2': [[8, 7], [8, 6]]}\n    var board = sampleBoardDicts[\"pawnPromo\"];\n\n    specialMoves = new SpecialMoves()\n    specialMoves.setPromos(board, ranges, 'W')\n    var promos = mapListListXyToRf(specialMoves.promos)\n    var [promoStarts, promoDests] = getPromoStartAndDest(promos);\n    printBoard(board, \"white\", promoDests, null, promoStarts)\n\n    specialMoves = new SpecialMoves()\n    specialMoves.setPromos(board, ranges, 'B')\n    var promos = mapListListXyToRf(specialMoves.promos)\n    var [promoStarts, promoDests] = getPromoStartAndDest(promos);\n    printBoard(board, \"black\", promoDests, null, promoStarts)\n    \n\n}\n*/"]},"metadata":{},"sourceType":"module"}